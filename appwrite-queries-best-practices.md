# Appwrite Queries Best Practices

This guide summarizes official Appwrite documentation on query performance and query design.

## 1. Build queries with the SDK `Query` class

- Pass queries via the `queries` array (query strings generated by SDK helpers).
- Treat multiple query methods as logical `AND`.
- For `OR`-style matching, pass multiple values in supported methods (for example `Query.equal("status", ["open", "pending"])`).

Why:
- This follows Appwrite's documented query model and keeps query construction consistent across SDKs.

## 2. Use `select` aggressively to reduce payload size

- Return only required columns.
- Load relationship data only when needed.
- For relationships, explicitly select fields (or wildcards) you need.

Why:
- Appwrite notes this reduces response size, parsing cost, and database processing.

## 3. Prefer cursor pagination for dynamic/high-volume data

- Use `Query.cursorAfter(lastId)` / `Query.cursorBefore(firstId)` for feeds, chats, comments, and other frequently changing datasets.
- Use offset pagination (`limit` + `offset`) for smaller or relatively static lists where page numbers are important.

Why:
- Appwrite documents that large offsets get slower and can produce duplicates/missing items on changing datasets.

## 4. Skip totals when exact counts are not needed

- Use `total=false` on list endpoints powering infinite scroll / "load more" UX.
- Keep totals enabled only when exact counts are required (for example "Page X of Y").

Why:
- Appwrite states totals can trigger an extra COUNT operation and add latency on large/filtered queries.

## 5. Index every queried and ordered column

- Add indexes for all filter/order columns.
- For multi-column query patterns, create composite indexes that match those patterns.
- Use `fulltext` indexes for `search` queries.

Why:
- Appwrite explicitly recommends indexing every queried column and notes ordering/search requirements.

## 6. Be deliberate with relationship queries

- Filter relationship columns via dot notation: `relationshipKey.field`.
- Keep relationship field selection narrow to avoid loading unnecessary related data.

Why:
- Relationship filtering is supported, but broad relationship loading can increase payload and query cost.

## 7. Respect API-side query limits

- Keep query payloads concise and predictable.
- In API references, Appwrite documents limits such as a maximum count/size for query strings on list endpoints.

Why:
- Prevents oversized or overly complex query payloads from becoming an operational issue.

## Practical pattern snippets

```ts
// Dynamic feed: cursor pagination + no totals + minimal fields
[
  Query.select(["id", "title", "author.name", "createdAt"]),
  Query.orderDesc("createdAt"),
  Query.limit(20),
  Query.cursorAfter(lastId)
]
// list(..., total=false)
```

```ts
// Filter on related row field + explicit select
[
  Query.equal("author.name", ["Alice"]),
  Query.select(["id", "title", "author.name"])
]
```

```ts
// Search requires a fulltext index on queried text column(s)
[
  Query.search("title", "payment retries")
]
```

## Source Docs

- Queries: https://appwrite.io/docs/products/databases/queries
- Pagination: https://appwrite.io/docs/products/databases/pagination
- Tables (indexes, search requirements): https://appwrite.io/docs/products/databases/tables
- Relationships (dot-notation filtering): https://appwrite.io/docs/products/databases/relationships
- Databases API reference (query/total constraints): https://appwrite.io/docs/references/cloud/server-python/databases

